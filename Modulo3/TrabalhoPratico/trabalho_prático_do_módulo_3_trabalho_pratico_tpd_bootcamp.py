# -*- coding: utf-8 -*-
"""Trabalho Prático do Módulo 3 - trabalho_pratico_TPD_bootcamp.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1I84UCiNjL2blGJeHameMybAmQocTFT9z
"""

import numpy as np #biblioteca utilizada para trabalhar com vetores
import pandas as pd #biblioteca para trabalhar com dataframes (planilhas excel)
import seaborn as sns #biblioteca utilizada para criar gráficos mais "bonitos"
import matplotlib.pyplot as plt #biblioteca para criar gráficos "comuns" ao estilo Matlab

#importando o banco de dados a ser utilizado (comando necessário para o google colab)
from google.colab import files
uploaded = files.upload()

# abrir o arquivo csv que contém os dados a serem utilizados durante a prática
uci_customers = pd.read_csv('wholesale_customers_data.csv')

#visualizando as 5 primeiras linhas do banco de dados
uci_customers.head()

"""1. FRESH: total anual gasto em produtos frescos;
2. MILK: total anual gasto em produtos derivados do leite;
3. GROCERY: total anual gasto em produtos de supermercado;
4. FROZEN: total anual gasto em produtos congelados;
5. DETERGENTS_PAPER: total anual gasto em produtos de limpeza;
6. DELICATESSEN: total anual gasto em produtos de delicatessen;
7. CHANNEL: tipo do canal de compra do consumidor (1- Horeca(hotel/restaurante/cafés) 2- varejo)
8. REGION: região do consumidor

**Quantas colunas (características) e linhas (instâncias) existem no dataset?**
"""

uci_customers.shape

"""**Quantos valores nulos (NAN) existem no dataset?**"""

#conhecendo o "formato" dos dados
uci_customers.info() #função para "ver" as variáveis presentes no dataset

uci_customers.isnull().sum() #função utilizada para contar a quantidade de valores nulos existente em cada uma das colunas (características) do dataset

#analisando o banco de dados
uci_customers.describe() #função que retorna uma análise superficial dos dados

""":**Qual é a valor médio de gasto anual com derivados do leite (Milk)?**

**Qual é o maior valor gasto com produtos congelados (Frozen)?**

**Verificando se existem outliers (anomalias) nos dados. Para isso, será utilizado o boxplot.**

**Existem possíves outliers para as colunas Fresh e Grocery?**
"""

plt.figure(figsize=(20,10))
uci_customers.boxplot(column=['Fresh','Grocery'])  #constroi o boxplot para o total gasto em alimentos frescos e de supermercado

"""**Explorando os dados. Entendendo alguns relacionamentos e comportamentos dos clientes.**"""

#analisando a distribuição dos clientes por gênero
sns.countplot(x='Region', data=uci_customers); # cria o gráfico que conta a quantidade de consumidores existente em cada uma das regiões
plt.title('Distribuição dos consumidores quanto à região');  #adiciona o título no gráfico

"""**Analisando o gráfico, o que podemos dizer sobre a distribuição de clientes por região?**

**Distribuição dos consumidores pelo gasto com produtos derivados do leite**
"""

#analisando a distribuição dos clientes quanto ao total de gastos com produtos derivados do leite através do histograma
uci_customers.hist('Milk', bins=50);  #seleciona a coluna de total de gastos para realizar o histograma
                                 # os "bins" indicam a quantidade de grupos que se deseja dividir os dados
plt.title('Distribuição dos clientes pelo gasto anual em produtos derivados do leite');# adiciona o título ao gráfico (histograma)
plt.xlabel('Gasto total em produtos derivados do leite');

"""**Analisando o gráfico anterior (histograma dos gastos com leite), o que podemos dizer sobre o valor anual gasto com produtos derivados do leite (Milk)?**"""

canal_1=uci_customers[uci_customers['Channel']==1] #seleciona o canal 1
canal_2= uci_customers[uci_customers['Channel']==2] #seleciona a comunicação pelo canal 2
plt.hist('Milk', data=canal_1, alpha=0.5, label='Canal_1'); #cria o histograma apenas do canal 1
plt.hist('Milk', data=canal_2, alpha=0.5, label='Canal_2'); #cria o histograma apenas para o canal 2
plt.title('Distribuição dos gastos com derivados do leite por canal'); #adiciona o título ao gráfico
plt.xlabel('Canal de Compra'); # adiciona o label para o eixo x
plt.legend(); #adiciona a legenda

"""**Analisando o gráfico anterior (histograma dos gastos por tipo de canal - 1 ou 2), o que podemos dizer sobre o valor anual gasto com produtos derivados do leite (Milk) por canal de consumo?**

**Analisando os gastos anuais com produtos de supermercado (pão, cereal, molhos etc).**
"""

uci_customers.hist('Grocery');  #criando um histograma para os os gastos totais dos consumidores com produtos de supermercado
plt.title('Distribuição dos gastos anuais dos consumidores com produtos de supermercado'); #adiciona o título no gráfico
plt.xlabel('Dinheiros (euros)'); # adiciona o label do eixo X

"""**Analisando o gráfico anterior (histograma dos gastos comprodutos de supermercado), o que podemos dizer sobre o padrão de consumo dos consumidores?**

**Analisando o impacto da região nos gastos com supermercado.**
"""

plt.figure(figsize=(20,10))


regiao_1=uci_customers[uci_customers['Region'] == 1]
regiao_2=uci_customers[uci_customers['Region'] == 2]
regiao_3=uci_customers[uci_customers['Region'] == 3]

plt.hist('Grocery', data=regiao_1, alpha=0.5, label='Região 1');
plt.hist('Grocery', data=regiao_2, alpha=0.5, label='Região 2');
plt.hist('Grocery', data=regiao_3, alpha=0.5, label='Região 3');

plt.title('Distribuição dos gastos com produtos de supermercado por região');
plt.xlabel('Região');
plt.legend();

corr = uci_customers['Grocery'].corr(uci_customers['Detergents_Paper'])
print(corr)

"""**Analisando o gráfico anterior (distribuição gastos com produtos de supermercado por região), o que podemos dizer sobre o padrão de consumo dos consumidores?**"""

#obtém os dados de cada um dos consumidores em cada região
regiao_1=uci_customers[uci_customers['Region'] == 1]
regiao_2=uci_customers[uci_customers['Region'] == 2]
regiao_3=uci_customers[uci_customers['Region'] == 3]

# obtém os valores médios atribuídos a cada uma das regiões
print('Valor anual médio gasto pelos clientes da região 1: \n',regiao_1[['Fresh','Milk','Grocery','Frozen','Detergents_Paper','Delicassen']].mean()) #imprime o valor médio para a região 1
print('Valor anual médio gasto pelos clientes da região 2: \n',regiao_2[['Fresh','Milk','Grocery','Frozen','Detergents_Paper','Delicassen']].mean()) #imprime o valor médio para a região 2
print('Valor anual médio gasto pelos clientes da região 3: \n',regiao_3[['Fresh','Milk','Grocery','Frozen','Detergents_Paper','Delicassen']].mean()) #imprime o valor médio para a região 3

#média dos gastos por cada uma das regiões e tipo de produto consumido
df_customers_mean=uci_customers.groupby('Region').mean() #agrupa por região e obtém os valores médios
df_customers_mean.plot(kind='bar',figsize=(20,10))  #realiza o plot

"""**Encontrando o valor gasto com Delicassen e Supermercado pela região**"""

plt.figure(figsize=(20,10))

sns.scatterplot('Delicassen', 'Grocery', hue='Region', data=uci_customers); #realiza o plot do gráfico dos gastos em supermercado com o
plt.title('Delicassen x Supermercado (colorido por Região)'); #adiciona o título ao gráfico

"""**Analisando a correlação entre as variáveis**"""

plt.figure(figsize=(20,10))

sns.heatmap(uci_customers.corr(), annot=True) # desenha a matriz de correlação entre cada um dos dados

"""**Analisando a correlação de Pearson entre os gastos com produtos de supermercado (Grocery) e produtos e higiene (Detergents_Paper), o que podemos dizer?**"""

plt.figure(figsize=(20,10))


sns.scatterplot('Grocery', 'Detergents_Paper', hue='Region', data=uci_customers);  #realiza o plot do gráfico de dispersão
plt.title('Compras em Supermercado x Detergente e Papel, (Colorido por região))'); #adiciona o título ao gráfico

"""**Aplicando a regressão linear - Prever o gasto com produtos de higiene a partir dos gastos com supermercado**"""

from sklearn.model_selection import train_test_split #utilizada para dividir o dataset entre dados de entrada e saída
from sklearn.linear_model import LinearRegression  #biblioteca que contém o modelo de regressão linear
from sklearn import metrics #utilizada para avaliar o modelo desenvolvido

X = uci_customers['Grocery'].values.reshape(-1,1)  #realiza a modificação dos dados para a entrada do algoritmo (transforma em uma matriz)
y = uci_customers['Detergents_Paper'].values.reshape(-1,1)  #realiza a modificação dos dados para a entrada do algoritmo (transforma em uma matriz)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=0) #dividindo o df em treinamento (80%) e teste (20%)

regressor = LinearRegression() #objeto para a construção do medelo de regressão linear
regressor.fit(X_train, y_train) #treinamento do algoritmo

plt.figure(figsize=(20,10))
y_pred = regressor.predict(X_test)  #previsão do modelo de regressão
plt.scatter(X_test, y_test,  color='gray')
plt.plot(X_test, y_pred, color='red', linewidth=2)
plt.xlabel('Gastos com produtos de supermercado')
plt.ylabel('Gastos com produtos de higiene')
plt.show()

#calculando o coeficiente de determinação R2 para o modelo
from sklearn.metrics import r2_score  #utilizada para calcular o R2
r2_score(y_test,y_pred)

#coeficientes da reta
print("A equação da reta é Y = {}*X {}".format(regressor.coef_[0],regressor.intercept_[0]))

#realizando a previsão de gastos com produtos de higiene dado que o consumidor gastou 25000 com supermercado
regressor.predict(np.array([30000]).reshape(-1,1))

"""**Qual é o coeficiente de determinação para o modelo de regressão encontrado?**

**Correlações por região 1**
"""

#região 1 - Lisboa
plt.figure(figsize=(20,10))
sns.heatmap(regiao_1.corr(), annot=True); #encontra a matriz de correlação da região 1
plt.title('Correlações apenas para a região 1'); #adiciona o título no gráfico

"""**Comparando a matriz de correlação total (todas as regiões) com a matriz de correlação apenas para região 1, o que podemos dizer sobre a correlação entre os gastos com produtos de supermercado (Grocery) e produtos e higiene (Detergents_Paper)?**

**Segmentação de clientes utilizando compras no supermercado e produtos de limpeza.**
"""

#biblioteca para realizar a construção do algoritmo não supervisionado K-means
from sklearn.cluster import KMeans

#obtém os dados para a construção do banco de dados apenas com compras de congelados e produtos de limpeza
segmentacao_1 = uci_customers[['Grocery' , 'Detergents_Paper']].iloc[: , :].values #transforma os dados em array

kmeans = KMeans(n_clusters=3) #contrói o modelo para aplicar o algoritmo de clusterização não supervisionado K-means
kmeans.fit(segmentacao_1) #aplica o modelo K-means aos dados
y_kmeans = kmeans.predict(segmentacao_1) #encontra os grupos

#inicia a construção da figura
plt.figure(figsize = (20 , 10) ) #define o tamanho da figura

plt.scatter(segmentacao_1[:, 0], segmentacao_1[:, 1], c=y_kmeans, cmap='viridis') #constrói o gráfco de dispersão com os grupos
centers = kmeans.cluster_centers_ #encontra os centros de cada um dos grupos
plt.scatter(centers[:, 0], centers[:, 1], c='black', s=200, alpha=0.5) #realiza o plot de cada um dos grupos
plt.xlabel("Gastos com supermercado")  #adiciona o label para o eixo X
plt.ylabel("Gastos com produtos de higiene") #adiciona o label para o eixo Y
plt.title("Segmentação de clientes por gastos com  Produots de supermercado x Produtos de higiene") #adiciona o título

"""**Analisando a segmentação de clientes pelos gastos com supermercado e produtos de higiene, o que podemos dizer sobre os 3 grupos criados (clusters)?**"""